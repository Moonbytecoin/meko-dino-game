git add src/MekoGame.js
git commit -m "fix: clean rebuild with working game and removed 
secret"
git push -f origin main
import React, { useEffect, useRef, useState } from 
"react";

const MekoGame = () => {
  const jumpSound = new Audio("https://www.myinstants.com/media/sounds/jump-sound.mp3");
  const music = new Audio("https://assets.mixkit.co/music/preview/mixkit-arcade-game-loop-251.mp3");
  music.loop = true;
  const canvasRef = useRef(null);
  const [started, setStarted] = useState(false);
  const [gameOver, setGameOver] = useState(false);
  const [finalScore, setFinalScore] = useState(0);
  const keys = useRef({});

  useEffect(() => {
    if (!started || gameOver) return;

    music.play();

    const canvas = canvasRef.current;
    const ctx = canvas.getContext("2d");

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const mekoImg = new Image();
    mekoImg.src = process.env.PUBLIC_URL + "/meko.png";
    const eggImg = new Image();
    eggImg.src = process.env.PUBLIC_URL + "/egg.png";
    const backgroundImg = new Image();
    backgroundImg.src = process.env.PUBLIC_URL + "/background.png";

    const meko = {
      x: 50,
      y: canvas.height - 150,
      width: 100,
      height: 100,
      velocityY: 0,
      speed: 5,
      jumpForce: 14,
      grounded: true,
    };

    const gravity = 0.6;
    let obstacles = [];
    let egg = {
      x: canvas.width - 100,
      y: canvas.height - 120,
      width: 60,
      height: 60,
      collected: false,
    };
    let score = 0;
    let frameCount = 0;
    let obstacleInterval;

    const spawnObstacle = () => {
      const height = 30 + Math.random() * 50;
      const width = 30 + Math.random() * 50;
      const x = canvas.width + 50;
      const y = canvas.height - height - 50;
      const dirY = Math.random() < 0.5 ? 1 : -1;
      const dirX = Math.random() < 0.5 ? 1 : -1;
      const baseY = y;
      const baseX = x;

      obstacles.push({
        x,
        y,
        width,
        height,
        speed: 2 + Math.random() * 2,
        dirY,
        dirX,
        baseY,
        baseX,
      });
    };

    const resetGame = () => {
      setFinalScore(score);
      setGameOver(true);
      music.pause();
      music.currentTime = 0;
    };

    const update = () => {
      if (gameOver) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);

      // Movement + gravity
      if (!meko.grounded) meko.velocityY += gravity;
      meko.y += meko.velocityY;

      if (meko.y >= canvas.height - meko.height - 50) {
        meko.y = canvas.height - meko.height - 50;
        meko.velocityY = 0;
        meko.grounded = true;
      }

      if (keys.current["ArrowRight"] || keys.current["KeyD"]) {
        meko.x += meko.speed;
        if (meko.x + meko.width > canvas.width) meko.x = canvas.width - meko.width;
      }

      if (keys.current["ArrowLeft"] || keys.current["KeyA"]) {
        meko.x -= meko.speed;
        if (meko.x < 0) meko.x = 0;
      }

      ctx.drawImage(mekoImg, meko.x, meko.y, meko.width, meko.height);

      // Draw and move obstacles
      for (let ob of obstacles) {
        ob.x -= ob.speed;

        ob.y += ob.dirY;
        if (ob.y > ob.baseY + 50 || ob.y < ob.baseY - 50) ob.dirY *= -1;

        ob.x += ob.dirX;
        if (ob.x > ob.baseX + 50 || ob.x < ob.baseX - 50) ob.dirX *= -1;

        ctx.fillStyle = "red";
        ctx.fillRect(ob.x, ob.y, ob.width, ob.height);

        if (
          meko.x < ob.x + ob.width &&
          meko.x + meko.width > ob.x &&
          meko.y < ob.y + ob.height &&
          meko.y + meko.height > ob.y
        ) {
          resetGame();
          return;
        }
      }

      if (!egg.collected) {
        ctx.drawImage(eggImg, egg.x, egg.y, egg.width, egg.height);
        if (
          meko.x < egg.x + egg.width &&
          meko.x + meko.width > egg.x &&
          meko.y < egg.y + egg.height &&
          meko.y + meko.height > egg.y
        ) {
          egg.collected = true;
          meko.width *= 1.3;
          meko.height *= 1.3;
          score += 10;
        }
      }

      // Score
      frameCount++;
      if (frameCount % 60 === 0) score++;

      ctx.fillStyle = "#000";
      ctx.font = "20px Arial";
      ctx.fillText("Score: " + score, 20, 30);

      requestAnimationFrame(update);
    };

    const handleKeyDown = (e) => {
      keys.current[e.code] = true;
      if (e.code === "Space" && meko.grounded) {
        jumpSound.play();
        meko.velocityY = -meko.jumpForce;
        meko.grounded = false;
      }
    };

    const handleKeyUp = (e) => {
      keys.current[e.code] = false;
    };

    let loadedImages = 0;
    const tryStart = () => {
      loadedImages++;
      if (loadedImages === 3) {
        document.addEventListener("keydown", handleKeyDown);
        document.addEventListener("keyup", handleKeyUp);
        obstacleInterval = setInterval(spawnObstacle, 2500);
        update();
      }
    };

    mekoImg.onload = tryStart;
    eggImg.onload = tryStart;
    backgroundImg.onload = tryStart;

    return () => {
      clearInterval(obstacleInterval);
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
      music.pause();
    };
  }, [started, gameOver]);

  return (
    <div style={{ width: "100vw", height: "100vh", overflow: "hidden" }}>
      {!started ? (
        <div style={{ position: "absolute", width: "100%", height: "100%", background: "#fff", display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column" }}>
          <img src={process.env.PUBLIC_URL + "/meko.png"} alt="Start" style={{ width: 100, height: 100, marginBottom: 20 }} />
          <button onClick={() => setStarted(true)} style={{ padding: 12, fontSize: 18 }}>Start Game</button>
        </div>
      ) : gameOver ? (
        <div style={{ position: "absolute", width: "100%", height: "100%", background: "#fff", display: "flex", justifyContent: "center", alignItems: "center", flexDirection: "column" }}>
          <h1>Game Over</h1>
          <p>Score: {finalScore}</p>
          <button onClick={() => { setStarted(false); setGameOver(false); }}>Restart</button>
        </div>
      ) : (
        <canvas ref={canvasRef} style={{ display: "block", width: "100%", height: "100%" }} />
      )}
    </div>
  );
};

export default MekoGame;

